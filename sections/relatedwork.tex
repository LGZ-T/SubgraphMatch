\section{Related Work}
\subsection{CPU-based Subgraph Matching}
An early attempt for subgraph matching is Ullmann \cite{ullmann1976algorithm}. They use a tree-search based approach to mine subgraphs and a look-ahead function to prune search space. Many works \cite{cordella2001improved, shang2008taming,zhang2009gaddi,he2008graphs,zhao2010graph} based on Ullmann have been proposed. VF2 \cite{cordella2001improved} uses degree information of vertices to prune the search space further. QuickSI \cite{shang2008taming} proposes to match vertices that have infrequent vertex and edge labels to eliminate invalid embeddings as early as possible. GADDI \cite{zhang2009gaddi}, GraphQL \cite{he2008graphs}, and SPath \cite{zhao2010graph} utilize the neighborhood information to remove unqualified data vertices from the candidate set for each query vertex. CECI \cite{bhattarai2019ceci} proposes a compact embedding cluster index to divide the data graph into embedding clusters and conduct subgraph matching on each embedding cluster. The main focus of these algorithms is to reduce the size of candidate sets. They do not take into account the impact of the matching order of query vertices on the matching performance, as pointed out in \cite{lee2012depth}.

In order to further improve the performance of subgraph matching, subsequent works \cite{han2013turboiso,ren2015exploiting,bi2016efficient,han2019efficient,rivero2017efficient} try to build auxiliary data to devise an effective matching order. TurboIso \cite{han2013turboiso} first identifies candidate regions in a data graph and then generates a matching order for each candidate region based on the number of candidate vertices of query vertices in this candidate region. BoostIso \cite{ren2015exploiting} exploits relationships between vertices in a data graph to remove duplicate computations. CFL \cite{bi2016efficient} decomposes the query graph into the core-forest-leaf structure and matches the core structure first to eliminate invalid embeddings as early as possible. Han et al. \cite{han2019efficient} builds a directed acyclic graph (DAG) for a query graph and then generates a matching order based on the DAG. SGMatch \cite{rivero2017efficient} decomposes the query graph into graphlets and then generates a matching order based on graphlets.

In recent years, many parallel subgraph matching algorithms have emerged.  Distributed subgraph matching  has been explored in \cite{afrati2013enumerating, shao2014parallel,shi2020graphpi,talukder2016distributed,sun2018parallelizing,plantenga2013inexact,reza2018prunejuice}. These approaches use MPI and MapReduce to distribute subgraph matching tasks to different compute nodes.

Different from CPU-based approaches, our work focuses on exploiting a GPU's massive parallelism to match a query graph in a data graph.

\subsection{GPU-based Subgraph Matching}
GPU has been used to accelerate applications in many fields because of its massive parallelism. There are several works exploiting GPU acceleration for subgraph matching. TRICORE \cite{hu2018tricore}  and \cite{green2014fast} design a GPU-based triangle counting method. Guo at el. \cite{guo2020gpu} partitions the data graph that beyond the GPU memory into subgraphs and matches the query graph in each subgraph iteratively. They also propose an embedding reuse method to avoid repeated computation in the work \cite{guo2020exploiting}. GSI \cite{zeng2020gsi}, GSM \cite{wang2020fast}, GpSM \cite{tran2015fast}, and \cite{lin2016network} utilize auxiliary data to assist candidate pruning and some GPU-based optimization techniques to speed up the matching process. While these works adopt the single-vertex extension method, our approach uses the double-vertex extension method to reduce the number of read and write operations of partial embeddings.

