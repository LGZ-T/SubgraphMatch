\section{Related Work}
\subsection{CPU-based Subgraph Search}
An early attempt for subgraph search is Ullmann \cite{ullmann1976algorithm}, which uses a tree-search based approach to mine subgraphs. Many works \cite{cordella2001improved, shang2008taming,zhang2009gaddi,he2008graphs,zhao2010graph} based on Ullmann have been proposed. VF2 \cite{cordella2001improved} and QuickSI \cite{shang2008taming} utilize vertex and edge information to eliminate invalid embeddings. GADDI \cite{zhang2009gaddi}, GraphQL \cite{he2008graphs}, and SPath \cite{zhao2010graph} utilize the neighborhood information to remove unqualified data vertices from the candidate set for each query vertex. CECI \cite{bhattarai2019ceci} proposes a compact embedding cluster index to divide the data graph into embedding clusters and conduct subgraph matching on each embedding cluster.

Subsequent works \cite{han2013turboiso,ren2015exploiting,bi2016efficient,han2019efficient,rivero2017efficient} try to build auxiliary data to devise an effective matching order. TurboIso \cite{han2013turboiso} first identifies candidate regions in a data graph and then generates a matching order for each candidate region based on the number of candidate vertices of query vertices in this candidate region. CFL \cite{bi2016efficient} decomposes the query graph into the core-forest-leaf structure and matches the core structure first to eliminate invalid embeddings as early as possible. SGMatch \cite{rivero2017efficient} decomposes the query graph into graphlets and then generates a matching order based on graphlets. Distributed subgraph search has been explored in \cite{afrati2013enumerating, shao2014parallel,shi2020graphpi,talukder2016distributed,sun2018parallelizing,plantenga2013inexact,reza2018prunejuice}. These approaches use MPI and MapReduce to distribute subgraph search tasks to different compute nodes.

Different from CPU-based approaches, our work focuses on exploiting a GPU's massive parallelism to match a query graph in a data graph.

\subsection{GPU-based Subgraph Search}
GPU has been used to accelerate applications in many fields because of its massive parallelism. There are several works exploiting GPU acceleration for subgraph search. TRICORE \cite{hu2018tricore}  and \cite{green2014fast} design a GPU-based triangle counting method. Guo at el. \cite{guo2020gpu} partitions the data graph that beyond the GPU memory into subgraphs and matches the query graph in each subgraph iteratively. They also propose an embedding reuse method to avoid repeated computation in the work \cite{guo2020exploiting}. GSI \cite{zeng2020gsi}, GSM \cite{wang2020fast}, GpSM \cite{tran2015fast}, and \cite{lin2016network} utilize auxiliary data to assist candidate pruning and some GPU-based optimization techniques to speed up the matching process. While these works adopt the single vertex matching method, our approach uses parallel vertex matching method to reduce the number of read and write operations of  embeddings.

